---
title: 3-6. 번들러 학습
description: 번들러 학습
---

# 3-6. 번들러 학습

개발 과정을 이어가면서 가장 큰 깨달음 중 하나는, "이거 다 뒤지고 맞물려 있는데 나는 아예 모르겠네"였다. 그중에서도 번들러는 웹·React Native 모두에서 중요한 역할을 하면서 정작 이야기할 사람이 잘 안 있었던 도메인이라, 이걸 열심히 공부해보기로 했다.

---

## 웹 프로젝트 기준으로 배우는 번들러

처음에는 웹 프로젝트에서 쓰는 번들러부터 익혔다. 웹은 환경이 통일돼 있어서 접근하기 쉬웠고, 대표적인 선택지가 보기 좋았다.

### Webpack

가장 무겁지만 제일 오래되고 친숙한 대장.

CRD는 이미 웹에서 CDP 클라이언트를 불러오기 위해 자바스크립트 파일을 쓰고 있었다. 그런데 Webpack으로 번들링을 하면서 이게 아주 큰 장벽이 되더라.

- Source Map 생성 규칙을 이해 안 하면 디버깅할 때 한참 헤맨다
- Webpack dev server와 Inspector의 WebSocket 연결이 꼬이는 경우가 잦아서, 구성을 다시 공부해야 했다
- CDP를 사용하는 코드가 번들링 될 때 어떻게 배포되는지 감을 잡기가 힘들었다

### Vite

Webpack 대신 Vite를 써보려고 했는데, 개발 서버의 설정이 생각보다 많이 달랐다.

- HMR(Hot Module Replacement) 동작方式이 webpack(HMR over WebSocket)과 다르다
- Vite는 dev server가 별도로 띄우는 거라 Inspector가 클라이언트에 접속하는 접근 경로가 달라진다
- ES modules 기본 사용이라 module type을 구분하는게 익숙하지 않은 환경에서는 헤깔린다

### 나중에 써보니

결국에는 Vite가 개발 경험에 훨씬 좋았다. 빠르고, HMR도 빠르고, 설정도 간결해서. 근데 Vite에 맞춰 Inspector 클라이언트를 다시 짜야 해서 복잡도는 같더라.

배민 기술 블로그에서 그땐 Webpack을 썼다 하고, 이번엔 Vite를 쓰는 걸로 바꾸는 과정에서 진짜 번들러가 어떻게 개발 환경에 연결되는지 완전히 이해하게 됐다.

---

## React Native와 Metro Bundler

웹에서 익힌 걸 가지고 React Native로 옮겨왔지만, 역시나 여기도 다르더라.

### Metro bundler 문서부터 공부

React Native가 Metro로 모든 걸 묶고, React Native 웹으로 변환하면 webpack으로 다시 묶는 식인데, 이 과정의 세탁기를 잘 몰라서 곤란했다.

### Inspector와 Metro의 연결 공부

Metro는 WebSocket과 같은 네트워크 메커니즘도 있는데, CDP Inspector와 이걸 어떻게 연결할지 고민했다.

- Metro bundler에서 어떻게 CDP 메시지를 인지할 수 있을까?
- 실시간 에러·경고 콘솔 로그를 Metro가 Inspector로 보낼 수 있을까?

결과적으로는 Metro의 devtoolServerUrl 옵션을 쓰면, 웹 개발할 때처럼 Inspector가 Metro와 WebSocket 통신할 수 있는 구성을 만들 수 있었다.

### 실제 적용

Inspector 패널에 "Metro Bundle"라는 항목을 추가해서 실제 Metro bundler 빌드 로그를 볼 수 있게 했다.

- Metro 서버가 빌드 완료 후 Inspector에게 이벤트를 보낸다
- Inspector에서 이걸 받아서 콘솔·에러·경고로 표시
- 빌드 에러가 있으면 빨간 박스로 강조해서 확 줄여줌

이 부분이 React Native 개발자들에게 정말 필요한 기능이라 기획했지만, 실제로 써보고 개발하면서 역시나 "이걸 몰랐으면 빌드 시간 동안 헤매기 그지없겠네" 하더라.

---

## 번들러별로 최적화 점

번들러 공부하면서 각각 최적화할 수 있는 부분도 정리했다.

### Webpack

- Code Splitting 설정을 엄청 조정해서 bundle 크기를 줄였다
- Lazy loading 구조를 기존 대로 두지 않고, 필요한 만큼만 잘게 쪼갰다
- Source Maps의 tokenization 레벨을 조절해서 크기를 줄이면서도 디버깅은 유지

### Vite

- Esbuild를 사용해서 빌드 속도를 급격히 개선했다
- HMR latency를 줄여서 에디터에서 저장하니까 거의 즉시 반영되게 했다
- Build output의 chunk naming을 명확하게 바꿔서 불필요한 캐싱을 방지

### Metro

- Hermes 관련 옵션을 다 조정해서 빌드 속도를 올렸다
- HMR에서의 메모리 leak을 수정해서 long-running 빌드에서 이슈가 안 나도록 했다
- devtoolServerUrl 설정을 개선해서 Metro 웹 개발과 Inspector가 더 유연하게 연동되게 했다

---

## 결론: 번들러는 DX의 중심

결국 번들러 하나로 완전히 다른 개발 환경을 만들 수 있다.

- Webpack은 장점이 많지만 설정이 무거우고, DX는 워낙 크기 때문에 학습 비용이 크다.
- Vite는 빠르고 직관적이지만, 그만큼 안쪽 동작을 바꾸면 영향이 크다.
- Metro는 React Native 고유의 특성을 가졌기 때문에 기존 웹 개발자들 입장에서는 낯설다.

이걸 깊게 공부하면서 느낀 건, 번들러는 "이걸 쓰고 싶어" 하는 선택이 아니라 "이걸 쓰면 이런 환경이 되고, 그게 나의 개발 철학과 얼마나 잘 어울리는가"를 따져 결정해야 한다.

CRD도 결국 개발 환경의 일부니까, 내가 쓸 번들러에 맞춰 CRD 자체를 설계·구현하면 DX가 급상승하는 것을 확인했고, 그게 번들러 학습의 결정적인 이유였다.

:::info 1줄 요약
Webpack, Vite, Metro 번들러의 동작 방식과 최적화 포인트를 파헤쳤다. 웹과 React Native 간 환경 차이를 이해하고, 번들러 선택이 DX에 미치는 영향을 깊게 공부했다. 결국 번들러는 자의적인 선택이 아니라 개발 스타일과 완전히 맞물려 있다는 걸 배웠다.
:::